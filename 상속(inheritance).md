

# 상속(inheritance)

- 자바의 모든 객체들은 상속이라는 객체지향 언어의 특징을 지원한다.

- 자바에서 생성되는 모든 객체들은 기본적으로 java.lang.object라는 객체를 상속하게 된다.

- 실무에서 객체가 필요할때만 클래스를 만든다.(자바안에 내장되어있는 경우는 만들필요 없음)

- 클래스 헤더에 exetdns라는 절을 사용하는 부모 클래스를 설정하는데 하나의 부모 클래스만 설정 가능하다.(C++과 다른점)

  - 자바는 단일 상속 이다.

- 조상으로부터 물려받은 메서드들은 필요에 따라 대체할 수 있다. 

  -  메서드오버라이딩이라 한다.

- 메서드에 관련되어서 메서드 오버라이딩/ 메서드 오버로딩 두개가 있다.

- 어떤 클래스든 객체를 생성하면 해당 클래스만 메모리를 할당하는 것이 아니라 조상 클래스들도 메모리 할당한다.

- 자손클래스의 객체 생성시 생성자 메서드가 호출되면 바로 조상클래스의 생성자도 호출된다.

- 내부적으로는 아규먼트 없는 생성자가 호출 되는데 다른 생성자를 호출하려는 경우 super라는 메서드를 사용한다.

- 객체를 참조하는 용도: this(나의 멤버), super(조상의 멤버)

- 객체를 초기화 하는 용도로 사용되는 생성자 메서드 호출: this(), super()

-  this(), super(): 생성자 안에서만 호출 가능

- this, super: 객체 생성 시점에 초기화 된다. static 메서드에서는 사용 불가하다.

  - non-static메서드와 생성자 메서드에서만 사용 가능 하다.

  

### 컴파일러의 역할

- 생성자 메서드 없는 애들은 생성자 메서드를 채워준다.
- 부모 지정 없는 애들도 java.lang으로 자동 지정
- 자바소스를 읽고 자바실행파일로 생성하는것
- 자바에 구문에 맞춰 반드시 있어야 할 구현내용이 없을때 기본사양에 맞게 채워넣어 준다.



# 제어자:modifier(수정자, 한정자, 제어자)

- 접근제어자: public, protected, (default)// 접근제어자를 안준 경우를 default, private

- 활용 제어자: final, static, abstract, trasient, synchronized

##### 제어자란 클래스, 메서드, 변수 앞에 설정되어  접근 가능 여부와 사용방식을 제어하는 구문

```java
[제어자] class 클래스명 extends 부모클래스명{
    [제어자] 멤버변수 선언:
    
    [제어자] 생성자 메서드 정의:
    
    [제어자] 메서드 정의:
}//제어자는 생략 가능
```



 ```java
[제어자: public, final, abstract] class 클래스명 extends 부모클래스명{
    [모든 접근 제어자] [멤버변수:final, static] 선언://final, static을 같이 주는 경우도 있다.
    
    [모든 접근 제어자(활용접근 제어자 제외)] 생성자 메서드 정의:
    
    [모든 접근 제어자, static, final abstract] 메서드 정의:
}//제어자는 생략 가능
 ```

- 클래스에는 접근제어자를 두가지만 설정 가능: public, (default)

  - public 클래스: 누구나
  - (default 클래스): 동일 패키지내의 클래스

- final - 변경할 수 없는, 마지막의

  abstract- 반드시 변경 해야만 하는, 마지막이 아닌

//final과 abstract는 같이 쓰면 오류난다.

​		final 클래스 : 상속 불가, 객체 생성 가능

​		abstract 클래스: 객체 생성 불가, 상속만 가능



- public - 누구나

  protected - 동일 패키지이거나, 자손이면 접근 가능

  (default) - 동일 패키지

  private - 자손이든 객체 생성한 클래스든 접근 불가

  ​				멤버가 정의된 클래스 내에서만 사용 가능

- 클래스 다이어그램에서

  - +: public
  - #: protected
  - (), ~ :(default)
  - ㅡ  :private​

- static final을 지정하여 상수를 만든다.

```java
public class Math {
public final static double PI = 3.14159;
}
```

Math.pi

Integer.MAX_VALUE

- 메서드에

  final : 자손에 의해 오버라이딩이 불가능한 메서드를 정의

  abstract: 	자손에 의해 반드시 오버라이딩 해야 하는 메서드를 정의
  					메서드의 헤더만 정의되고 바디가 없는 메서드

  ![image-20191213143425554](C:\Users\student\AppData\Roaming\Typora\typora-user-images\image-20191213143425554.png)

-> 접근제어자를 같거나 넓힐수는 있어도 좁힐 수는 없다.



# 포함관계(composite)

-  포함이란?
  - 한 클래스의 멤버변수로 다른 클래스를 선언하는 것
  - 작은 단위의 클래스를 먼저 만들고, 이 들을 조합해서 하나의 커다란 클래스를 만든다

![image-20191213144532402](C:\Users\student\AppData\Roaming\Typora\typora-user-images\image-20191213144532402.png)



- 포인트를 상속한 것이 아니라 함께 포함관계로 만들었다.

### 상속 vs 포함

- 가능한 한 많은 관계를 맺어주어 재사용성을 높이고 관리하기 쉽게 한다.
- ‘is-a’와 ‘has-a’를 가지고 문장을 만들어 본다
  - is a 상속(~은 ~이다 관계가 자연스러우면)
  - has a 포함(~은 ~을 가지고 있다라는 관계가 자연스러우면)



### 단일 상속

-  Java는 단일상속만을 허용한다.(C++은 다중상속 허용
- 비중이 높은 클래스 하나만 상속관계로, 나머지는 포함관계로 한다.



### Object클래스 – 모든 클래스의 최고조상

- 조상이 없는 클래스는 자동적으로 Object클래스를 상속받게 된다.
- 다형성과 연관된 개념



### 오버라이딩(overriding)

- 조상클래스로부터 상속받은 메서드의 내용을 상속받는 클래스에 맞게 변경하는 것을 오버라이딩이라고 한다.

- 조상이 갖고 있는 메소드 중에서 final은 상속할 수 없다.

- bstract은 무조건 오버라이딩 해야 한다.

  

### 오버라이딩의 조건

- 선언부가 같아야 한다.(이름, 매개변수, 리턴타입)
- 접근제어자를 좁은 범위로 변경할 수 없다
- 조상클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.



### 오버로딩 vs 오버라이딩

오버로딩: 기존에 없는 새로운 메서드를 정의하는 것

오버라이딩: 상속받은 메서드의 내용을 변경하는 것

```java
class parent{
	void parentMethod(){}
}
class Child extends parent{
	void parentMethod(){}//오버라이딩
	oid parentMethod(int i){}//오버로딩
}
```

### super 참조변수

- this: 인스턴스 자신을 가리키는 참조변수. 인스턴스의 주소가 저장되어있음

  ​        모든 인스턴스 메서드에 지역변수로 숨겨진 채로 존재

- super:  this와 같음. 조상의 멤버와 자신의 멤버를 구별하는 데 사용. 

- 자손클래스의 인스턴스를 생성하면, 자손의 멤버와 조상의 멤버가 합쳐진

    하나의 인스턴스가 생성된다.

- 조상의 멤버들도 초기화되어야 하기 때문에 자손의 생성자의 첫 문장에서

   조상의 생성자를 호출해야 한다